1.) Concurrent read with the commited value and exculsive writes with locks
2.)You have a set of tiles, where each tile has one letter tiles[i] printed on it.  
Return the nu mber of possible non-empty sequences of letters you can make.

Example 1:

Input: "AAB"
Output: 8
Explanation: The possible sequences are "A", "B", "AA", "AB", "BA", "AAB", "ABA", "BAA".
Example 2:

Input: "AAABBC"
Output: 188
 

Note:

1 <= tiles.length <= 7
tiles consists of uppercase English letters.

5.) Given an integer array find the max median for K iterations
For example : 1 , 2, 5, 3, 5 K = 2 Max median = 5

				 

7.) Find the longest path in  binary tree
8.) Given a pair of groups merge the group which matches X and Y. 
	
		[1,3]
		[6,8]
		[10, 12]
		[8,3]
		
For example  
		[1, 3] 
		[6, 8] --> Is not matching with previous group so inserting as a new group
		[10 ,12 ] --> Is not matching with previous group so inserting as a new group
		[8,3]  --> 8 is present in [ 6, 8] and 3 is matching with [1,3], so this can be grouped into one [1, 3, 6 , 8] 
		so now we have only 2  groups below and output that

		[1,3,6, 8]
		[10, 12]


======================

[ 1 , 2, 4, 5]
[ 10, 4, 2, 1]
[ 5,  6, 7, 8]

======================


1 => 10 => 5 = 16
2 => 2 => 6 = 10
1 => 4 => 5 = 10


M * N

[1,2,4,5]
[10,4,2,1]
[5,6,7,8]

[11(1+10),5(1+4),4(2+2),5(4+1)]


[5,6,7,8]
11,5,4,5]10, 10, 11, 13






1,4 => 5
2,4 => 6 
4,4 => 8


A wall of bricks, two types: with holes (0) ; solid (1)
Rain can go through the brick with holes, but will be blocked by solid bricks 


0 1 0
0 0 1
1 0 1 




0,0  = 0
1,0 =  0
1,1 =  0



----------
Return true if there is a path for rain to reach ground 


Input: m*n 
Output: true/false



public bool FindWayForRainWater(int[,] input)
{
    if (input == null)
    {
        return false;
    }
    
  
    
    int rl = input.GetLength(0);
    int cl = input.GetLength(1);
    
    bool[,] visited = new bool[rl, cl];
    
    bool[,] reachable
    
    
    rechable[i,j] = input [i,j] == 0 && ( rechable [i-1, j] || rechable [i-1, j-1] || rechable [i-1, j+1] )
    
    int r = 0;
    int c = 0;
    
    while (r < rl && c< cl)
    {
    
       
                
            
                if (input[r,c] == 0 && r + 1 >0 && c + 1 > 0 && r+1 < rl && c+1 < cl && 
                    (input[r + i, c] == 0  || input[r+1 ,c + 1] ==0) && !visited[r+1 , c+ j])
            
            
    }
    
    
    }
    
    
    
    
    
    
}




